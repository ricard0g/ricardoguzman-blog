---
interface Props {
	title?: string;
	description?: string;
	ogDescription?: string;
	twitterDescription?: string;
	image?: string;
	imageAlt?: string;
	type?: "website" | "article";
	publishedTime?: string;
	modifiedTime?: string;
	author?: string;
	tags?: string[];
}

const {
	title = "Ricardo Guzman",
	description,
	ogDescription,
	twitterDescription,
	image,
	imageAlt,
	type = "website",
	publishedTime,
	modifiedTime,
	author,
	tags = [],
} = Astro.props as Props;

const DEFAULT_SITE_URL = "https://blog.ricardoguzman.dev";
const DEFAULT_DESCRIPTION =
	"This is my personal blog where I share personal and software-related findings";
const DEFAULT_IMAGE_PATH = "/og-image.png";
const SITE_NAME = "Ricardo Guzman";
const TWITTER_HANDLE = "@ricardoguzdev";

const siteBase = Astro.site ? Astro.site.toString() : DEFAULT_SITE_URL;
const canonicalUrl = new URL(Astro.url.pathname, siteBase).toString();
const siteDomain = new URL(siteBase).hostname;

const resolvedDescription = description?.trim()
	? description
	: DEFAULT_DESCRIPTION;
const resolvedOgDescription = ogDescription?.trim()
	? ogDescription
	: resolvedDescription;
const resolvedTwitterDescription = twitterDescription?.trim()
	? twitterDescription
	: resolvedDescription;
const resolvedImageAlt = imageAlt?.trim()
	? imageAlt
	: `Social image for ${title}`;

const imageCandidate = image?.trim() ? image : DEFAULT_IMAGE_PATH;
const resolvedImage = toAbsoluteUrl(imageCandidate, siteBase);
const isSecureImage = resolvedImage.startsWith("https://");
const imageMimeType = inferImageMimeType(resolvedImage);
const shouldAddFallbackDimensions =
	imageCandidate === DEFAULT_IMAGE_PATH ||
	imageCandidate === "/og-image.png" ||
	imageCandidate === "og-image.png";

function toAbsoluteUrl(value: string, base: string) {
	try {
		const parsed = new URL(value);
		if (parsed.protocol === "http:" || parsed.protocol === "https:") {
			return parsed.toString();
		}
	} catch {
		// continue with relative URL fallback
	}

	const normalizedPath = value.startsWith("/") ? value : `/${value}`;
	return new URL(normalizedPath, base).toString();
}

function inferImageMimeType(value: string) {
	const pathname = new URL(value).pathname.toLowerCase();
	if (pathname.endsWith(".png")) return "image/png";
	if (pathname.endsWith(".jpg") || pathname.endsWith(".jpeg")) {
		return "image/jpeg";
	}
	if (pathname.endsWith(".webp")) return "image/webp";
	if (pathname.endsWith(".gif")) return "image/gif";
	return undefined;
}
---

<meta name="description" content={resolvedDescription} />
<link rel="canonical" href={canonicalUrl} />

<meta property="og:site_name" content={SITE_NAME} />
<meta property="og:locale" content="en_US" />
<meta property="og:type" content={type} />
<meta property="og:url" content={canonicalUrl} />
<meta property="og:title" content={title} />
<meta property="og:description" content={resolvedOgDescription} />
<meta property="og:image" content={resolvedImage} />
<meta property="og:image:url" content={resolvedImage} />
{isSecureImage && <meta property="og:image:secure_url" content={resolvedImage} />}
{imageMimeType && <meta property="og:image:type" content={imageMimeType} />}
<meta property="og:image:alt" content={resolvedImageAlt} />
{
	shouldAddFallbackDimensions && (
		<>
			<meta property="og:image:width" content="1200" />
			<meta property="og:image:height" content="842" />
		</>
	)
}

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:site" content={TWITTER_HANDLE} />
<meta name="twitter:creator" content={TWITTER_HANDLE} />
<meta name="twitter:domain" content={siteDomain} />
<meta name="twitter:url" content={canonicalUrl} />
<meta name="twitter:title" content={title} />
<meta name="twitter:description" content={resolvedTwitterDescription} />
<meta name="twitter:image" content={resolvedImage} />
<meta name="twitter:image:src" content={resolvedImage} />
<meta name="twitter:image:alt" content={resolvedImageAlt} />

{
	type === "article" && publishedTime && (
		<meta property="article:published_time" content={publishedTime} />
	)
}
{
	type === "article" && modifiedTime && (
		<meta property="article:modified_time" content={modifiedTime} />
	)
}
{type === "article" && author && <meta property="article:author" content={author} />}
{
	type === "article" &&
		tags.map((tag) => <meta property="article:tag" content={tag} />)
}
